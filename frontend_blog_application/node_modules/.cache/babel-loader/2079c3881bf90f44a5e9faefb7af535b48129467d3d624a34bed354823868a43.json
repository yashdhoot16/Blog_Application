{"ast":null,"code":"/*!\n * Jodit Editor (https://xdsoft.net/jodit/)\n * Released under MIT see LICENSE.txt in the project root for license information.\n * Copyright (c) 2013-2025 Valeriy Chupurnov. All rights reserved. https://xdsoft.net\n */\nimport { IS_ES_NEXT, IS_IE } from \"../../constants.js\";\nimport { Dom } from \"../../dom/dom.js\";\nimport { toArray } from \"../array/to-array.js\";\nimport { isString } from \"../checker/is-string.js\";\nimport { camelCase } from \"../string/camel-case.js\";\nimport { attr, error } from \"./index.js\";\nlet temp = 1;\nconst $$temp = () => {\n  temp++;\n  return temp;\n};\n/**\n * @deprecated Do not use it in new code\n */\nexport function $$(selector, root) {\n  let result;\n  if (!IS_ES_NEXT && /:scope/.test(selector) && IS_IE && !(root && root.nodeType === Node.DOCUMENT_NODE)) {\n    const id = root.id,\n      temp_id = id || '_selector_id_' + String(Math.random()).slice(2) + $$temp();\n    selector = selector.replace(/:scope/g, '#' + temp_id);\n    !id && root.setAttribute('id', temp_id);\n    result = root.parentNode.querySelectorAll(selector);\n    if (!id) {\n      root.removeAttribute('id');\n    }\n  } else {\n    result = root.querySelectorAll(selector);\n  }\n  return [].slice.call(result);\n}\n/**\n * Calculate XPath selector\n */\nexport const getXPathByElement = (element, root) => {\n  if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n  if (!element.parentNode || root === element) {\n    return '';\n  }\n  if (element.id) {\n    return \"//*[@id='\" + element.id + \"']\";\n  }\n  const sames = [].filter.call(element.parentNode.childNodes, x => x.nodeName === element.nodeName);\n  return getXPathByElement(element.parentNode, root) + '/' + element.nodeName.toLowerCase() + (sames.length > 1 ? '[' + (toArray(sames).indexOf(element) + 1) + ']' : '');\n};\n/**\n * Find all `ref` or `data-ref` elements inside HTMLElement\n */\nexport const refs = root => {\n  if ('container' in root) {\n    root = root.container;\n  }\n  return $$('[ref],[data-ref]', root).reduce((def, child) => {\n    const key = attr(child, '-ref');\n    if (key && isString(key)) {\n      def[camelCase(key)] = child;\n      def[key] = child;\n    }\n    return def;\n  }, {});\n};\n/**\n * Calculate full CSS selector\n */\nexport const cssPath = el => {\n  if (!Dom.isElement(el)) {\n    return null;\n  }\n  const path = [];\n  let start = el;\n  while (start && start.nodeType === Node.ELEMENT_NODE) {\n    let selector = start.nodeName.toLowerCase();\n    if (start.id) {\n      selector += '#' + start.id;\n      path.unshift(selector);\n      break;\n    } else {\n      let sib = start,\n        nth = 1;\n      do {\n        sib = sib.previousElementSibling;\n        if (sib && sib.nodeName.toLowerCase() === selector) {\n          nth++;\n        }\n      } while (sib);\n      selector += ':nth-of-type(' + nth + ')';\n    }\n    path.unshift(selector);\n    start = start.parentNode;\n  }\n  return path.join(' > ');\n};\n/**\n * Try to find element by selector\n */\nexport function resolveElement(element, od) {\n  let resolved = element;\n  if (isString(element)) {\n    try {\n      resolved = od.querySelector(element);\n    } catch (_a) {\n      throw error('String \"' + element + '\" should be valid HTML selector');\n    }\n  }\n  // Duck checking\n  if (!resolved || typeof resolved !== 'object' || !Dom.isElement(resolved) || !resolved.cloneNode) {\n    throw error('Element \"' + element + '\" should be string or HTMLElement instance');\n  }\n  return resolved;\n}","map":{"version":3,"names":["IS_ES_NEXT","IS_IE","Dom","toArray","isString","camelCase","attr","error","temp","$$temp","$$","selector","root","result","test","nodeType","Node","DOCUMENT_NODE","id","temp_id","String","Math","random","slice","replace","setAttribute","parentNode","querySelectorAll","removeAttribute","call","getXPathByElement","element","ELEMENT_NODE","sames","filter","childNodes","x","nodeName","toLowerCase","length","indexOf","refs","container","reduce","def","child","key","cssPath","el","isElement","path","start","unshift","sib","nth","previousElementSibling","join","resolveElement","od","resolved","querySelector","_a","cloneNode"],"sources":["C:/Users/YDHOOT/Documents/Spring Tool Suite Projects/BlogApplication/frontend_blog_application/node_modules/jodit/esm/core/helpers/utils/selector.js"],"sourcesContent":["/*!\n * Jodit Editor (https://xdsoft.net/jodit/)\n * Released under MIT see LICENSE.txt in the project root for license information.\n * Copyright (c) 2013-2025 Valeriy Chupurnov. All rights reserved. https://xdsoft.net\n */\nimport { IS_ES_NEXT, IS_IE } from \"../../constants.js\";\nimport { Dom } from \"../../dom/dom.js\";\nimport { toArray } from \"../array/to-array.js\";\nimport { isString } from \"../checker/is-string.js\";\nimport { camelCase } from \"../string/camel-case.js\";\nimport { attr, error } from \"./index.js\";\nlet temp = 1;\nconst $$temp = () => {\n    temp++;\n    return temp;\n};\n/**\n * @deprecated Do not use it in new code\n */\nexport function $$(selector, root) {\n    let result;\n    if (!IS_ES_NEXT &&\n        /:scope/.test(selector) &&\n        IS_IE &&\n        !(root && root.nodeType === Node.DOCUMENT_NODE)) {\n        const id = root.id, temp_id = id ||\n            '_selector_id_' + String(Math.random()).slice(2) + $$temp();\n        selector = selector.replace(/:scope/g, '#' + temp_id);\n        !id && root.setAttribute('id', temp_id);\n        result = root.parentNode.querySelectorAll(selector);\n        if (!id) {\n            root.removeAttribute('id');\n        }\n    }\n    else {\n        result = root.querySelectorAll(selector);\n    }\n    return [].slice.call(result);\n}\n/**\n * Calculate XPath selector\n */\nexport const getXPathByElement = (element, root) => {\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n        return '';\n    }\n    if (!element.parentNode || root === element) {\n        return '';\n    }\n    if (element.id) {\n        return \"//*[@id='\" + element.id + \"']\";\n    }\n    const sames = [].filter.call(element.parentNode.childNodes, (x) => x.nodeName === element.nodeName);\n    return (getXPathByElement(element.parentNode, root) +\n        '/' +\n        element.nodeName.toLowerCase() +\n        (sames.length > 1\n            ? '[' + (toArray(sames).indexOf(element) + 1) + ']'\n            : ''));\n};\n/**\n * Find all `ref` or `data-ref` elements inside HTMLElement\n */\nexport const refs = (root) => {\n    if ('container' in root) {\n        root = root.container;\n    }\n    return $$('[ref],[data-ref]', root).reduce((def, child) => {\n        const key = attr(child, '-ref');\n        if (key && isString(key)) {\n            def[camelCase(key)] = child;\n            def[key] = child;\n        }\n        return def;\n    }, {});\n};\n/**\n * Calculate full CSS selector\n */\nexport const cssPath = (el) => {\n    if (!Dom.isElement(el)) {\n        return null;\n    }\n    const path = [];\n    let start = el;\n    while (start && start.nodeType === Node.ELEMENT_NODE) {\n        let selector = start.nodeName.toLowerCase();\n        if (start.id) {\n            selector += '#' + start.id;\n            path.unshift(selector);\n            break;\n        }\n        else {\n            let sib = start, nth = 1;\n            do {\n                sib = sib.previousElementSibling;\n                if (sib && sib.nodeName.toLowerCase() === selector) {\n                    nth++;\n                }\n            } while (sib);\n            selector += ':nth-of-type(' + nth + ')';\n        }\n        path.unshift(selector);\n        start = start.parentNode;\n    }\n    return path.join(' > ');\n};\n/**\n * Try to find element by selector\n */\nexport function resolveElement(element, od) {\n    let resolved = element;\n    if (isString(element)) {\n        try {\n            resolved = od.querySelector(element);\n        }\n        catch (_a) {\n            throw error('String \"' + element + '\" should be valid HTML selector');\n        }\n    }\n    // Duck checking\n    if (!resolved ||\n        typeof resolved !== 'object' ||\n        !Dom.isElement(resolved) ||\n        !resolved.cloneNode) {\n        throw error('Element \"' + element + '\" should be string or HTMLElement instance');\n    }\n    return resolved;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
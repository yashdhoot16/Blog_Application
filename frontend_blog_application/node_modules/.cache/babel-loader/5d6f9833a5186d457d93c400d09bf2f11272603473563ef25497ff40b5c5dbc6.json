{"ast":null,"code":"/*!\n * Jodit Editor (https://xdsoft.net/jodit/)\n * Released under MIT see LICENSE.txt in the project root for license information.\n * Copyright (c) 2013-2025 Valeriy Chupurnov. All rights reserved. https://xdsoft.net\n */\nimport { STATUSES } from \"../../component/statuses.js\";\nimport { IS_PROD } from \"../../constants.js\";\nimport { Dom } from \"../../dom/dom.js\";\nimport { isFunction, isViewObject } from \"../../helpers/checker/index.js\";\nimport { error } from \"../../helpers/utils/error/error.js\";\n/**\n * Retrieves a cached property value from an object if it exists; otherwise, returns `null`.\n *\n * This utility is particularly useful when working with properties that are lazily initialized\n * or dynamically created, such as getters or cached computations. It ensures you can safely\n * access the value without triggering initialization or creating a new instance.\n *\n * ### Usage Example:\n * ```typescript\n * import type { IUIElement } from \"jodit\";\n *\n * const { component, cache, cached } = Jodit.decorators;\n * const { UIElement } = Jodit.modules;\n *\n * @component\n * class SomeComponent extends UIElement {\n *   @cache\n *   get someElement(): IUIElement {\n *     return new UIElement(this.jodit);\n *   }\n *\n *   destruct() {\n *     // Use the cached utility to clean up only if the property is initialized\n *     cached(this, 'someElement')?.destruct();\n *     super.destruct();\n *   }\n * }\n * ```\n *\n * @param object - The object containing the property to check.\n * @param property - The name of the property to retrieve from the cache.\n * @returns The cached value of the property if it exists; otherwise, `null`.\n *\n * ### Notes:\n * - If the property is defined as a getter, the function will return `null`\n *   instead of invoking the getter.\n * - This function is non-destructive and does not alter the object's state.\n */\nexport function cached(object, property) {\n  const descriptor = Object.getOwnPropertyDescriptor(object, property);\n  if (!descriptor || isFunction(descriptor.get)) {\n    return null;\n  }\n  return descriptor.value;\n}\n/**\n * A decorator that caches the result of a getter method. Once the getter is accessed for the first time,\n * its computed value is stored as a property of the object. Subsequent accesses return the cached value\n * without recalculating it, improving performance and avoiding redundant computations.\n *\n * ### Key Features:\n * - **Lazy Initialization**: The original getter is invoked only once, the first time the property is accessed.\n * - **Immutability**: After caching, the value is stored as a non-writable, non-configurable property, preventing accidental modifications.\n * - **Conditional Caching**: If the returned value has a property `noCache` set to `true`, the caching mechanism is bypassed, and the getter is invoked each time.\n *\n * ### Usage Example 1: Basic Caching\n * ```typescript\n * import { cache } from './decorators';\n *\n * class Example {\n *   private counter = 0;\n *\n *   @cache\n *   get expensiveComputation(): number {\n *     console.log('Calculating...');\n *     return ++this.counter;\n *   }\n * }\n *\n * const instance = new Example();\n * console.log(instance.expensiveComputation); // Logs \"Calculating...\" and returns 1\n * console.log(instance.expensiveComputation); // Returns 1 (cached value, no calculation)\n * ```\n *\n * ### Usage Example 2: Integration with Cached Utilities\n * ```typescript\n * import { cache, cached } from './decorators';\n * import type { IUIElement } from \"jodit\";\n *\n * const { component } = Jodit.decorators;\n * const { UIElement } = Jodit.modules;\n *\n * @component\n * class SomeComponent extends UIElement {\n *   @cache\n *   get someElement(): IUIElement {\n *     return new UIElement(this.jodit);\n *   }\n *\n *   destruct() {\n *     // Use the cached utility to clean up only if the property is initialized\n *     cached(this, 'someElement')?.destruct();\n *     super.destruct();\n *   }\n * }\n * ```\n *\n * @param _ - The target object (not used directly).\n * @param name - The name of the property to decorate.\n * @param descriptor - The property descriptor, which must include a getter method.\n * @throws Will throw an error if the descriptor does not include a getter.\n *\n * ### Notes:\n * - **Performance**: Ideal for properties that are computationally expensive and do not change after the initial computation.\n * - **Flexibility**: Supports conditional caching via the `noCache` property in the returned value.\n * - **Compatibility**: Designed to work seamlessly with objects and classes in TypeScript or JavaScript.\n */\nexport function cache(_, name, descriptor) {\n  const getter = descriptor.get;\n  if (!getter) {\n    throw error('Getter property descriptor expected');\n  }\n  descriptor.get = function () {\n    if (!IS_PROD) {\n      if (this.isInDestruct) {\n        console.error('Trying to access property in destructed component');\n      }\n    }\n    const value = getter.call(this);\n    if (value && value.noCache === true) {\n      return value;\n    }\n    Object.defineProperty(this, name, {\n      configurable: descriptor.configurable,\n      enumerable: descriptor.enumerable,\n      writable: false,\n      value\n    });\n    return value;\n  };\n}\nexport function cacheHTML(target, _, descriptor) {\n  const fn = descriptor.value;\n  if (!isFunction(fn)) {\n    throw error('Handler must be a Function');\n  }\n  let useCache = true;\n  const cached = new WeakMap();\n  descriptor.value = function (...attrs) {\n    var _a;\n    if (useCache && cached.has(this.constructor)) {\n      return (_a = cached.get(this.constructor)) === null || _a === void 0 ? void 0 : _a.cloneNode(true);\n    }\n    const value = fn.apply(this, attrs);\n    if (useCache && Dom.isElement(value)) {\n      cached.set(this.constructor, value);\n    }\n    return useCache ? value.cloneNode(true) : value;\n  };\n  target.hookStatus(STATUSES.ready, component => {\n    const view = isViewObject(component) ? component : component.jodit;\n    useCache = Boolean(view.options.cache);\n  });\n}","map":{"version":3,"names":["STATUSES","IS_PROD","Dom","isFunction","isViewObject","error","cached","object","property","descriptor","Object","getOwnPropertyDescriptor","get","value","cache","_","name","getter","isInDestruct","console","call","noCache","defineProperty","configurable","enumerable","writable","cacheHTML","target","fn","useCache","WeakMap","attrs","_a","has","constructor","cloneNode","apply","isElement","set","hookStatus","ready","component","view","jodit","Boolean","options"],"sources":["C:/Users/YDHOOT/Documents/Spring Tool Suite Projects/BlogApplication/frontend_blog_application/node_modules/jodit/esm/core/decorators/cache/cache.js"],"sourcesContent":["/*!\n * Jodit Editor (https://xdsoft.net/jodit/)\n * Released under MIT see LICENSE.txt in the project root for license information.\n * Copyright (c) 2013-2025 Valeriy Chupurnov. All rights reserved. https://xdsoft.net\n */\nimport { STATUSES } from \"../../component/statuses.js\";\nimport { IS_PROD } from \"../../constants.js\";\nimport { Dom } from \"../../dom/dom.js\";\nimport { isFunction, isViewObject } from \"../../helpers/checker/index.js\";\nimport { error } from \"../../helpers/utils/error/error.js\";\n/**\n * Retrieves a cached property value from an object if it exists; otherwise, returns `null`.\n *\n * This utility is particularly useful when working with properties that are lazily initialized\n * or dynamically created, such as getters or cached computations. It ensures you can safely\n * access the value without triggering initialization or creating a new instance.\n *\n * ### Usage Example:\n * ```typescript\n * import type { IUIElement } from \"jodit\";\n *\n * const { component, cache, cached } = Jodit.decorators;\n * const { UIElement } = Jodit.modules;\n *\n * @component\n * class SomeComponent extends UIElement {\n *   @cache\n *   get someElement(): IUIElement {\n *     return new UIElement(this.jodit);\n *   }\n *\n *   destruct() {\n *     // Use the cached utility to clean up only if the property is initialized\n *     cached(this, 'someElement')?.destruct();\n *     super.destruct();\n *   }\n * }\n * ```\n *\n * @param object - The object containing the property to check.\n * @param property - The name of the property to retrieve from the cache.\n * @returns The cached value of the property if it exists; otherwise, `null`.\n *\n * ### Notes:\n * - If the property is defined as a getter, the function will return `null`\n *   instead of invoking the getter.\n * - This function is non-destructive and does not alter the object's state.\n */\nexport function cached(object, property) {\n    const descriptor = Object.getOwnPropertyDescriptor(object, property);\n    if (!descriptor || isFunction(descriptor.get)) {\n        return null;\n    }\n    return descriptor.value;\n}\n/**\n * A decorator that caches the result of a getter method. Once the getter is accessed for the first time,\n * its computed value is stored as a property of the object. Subsequent accesses return the cached value\n * without recalculating it, improving performance and avoiding redundant computations.\n *\n * ### Key Features:\n * - **Lazy Initialization**: The original getter is invoked only once, the first time the property is accessed.\n * - **Immutability**: After caching, the value is stored as a non-writable, non-configurable property, preventing accidental modifications.\n * - **Conditional Caching**: If the returned value has a property `noCache` set to `true`, the caching mechanism is bypassed, and the getter is invoked each time.\n *\n * ### Usage Example 1: Basic Caching\n * ```typescript\n * import { cache } from './decorators';\n *\n * class Example {\n *   private counter = 0;\n *\n *   @cache\n *   get expensiveComputation(): number {\n *     console.log('Calculating...');\n *     return ++this.counter;\n *   }\n * }\n *\n * const instance = new Example();\n * console.log(instance.expensiveComputation); // Logs \"Calculating...\" and returns 1\n * console.log(instance.expensiveComputation); // Returns 1 (cached value, no calculation)\n * ```\n *\n * ### Usage Example 2: Integration with Cached Utilities\n * ```typescript\n * import { cache, cached } from './decorators';\n * import type { IUIElement } from \"jodit\";\n *\n * const { component } = Jodit.decorators;\n * const { UIElement } = Jodit.modules;\n *\n * @component\n * class SomeComponent extends UIElement {\n *   @cache\n *   get someElement(): IUIElement {\n *     return new UIElement(this.jodit);\n *   }\n *\n *   destruct() {\n *     // Use the cached utility to clean up only if the property is initialized\n *     cached(this, 'someElement')?.destruct();\n *     super.destruct();\n *   }\n * }\n * ```\n *\n * @param _ - The target object (not used directly).\n * @param name - The name of the property to decorate.\n * @param descriptor - The property descriptor, which must include a getter method.\n * @throws Will throw an error if the descriptor does not include a getter.\n *\n * ### Notes:\n * - **Performance**: Ideal for properties that are computationally expensive and do not change after the initial computation.\n * - **Flexibility**: Supports conditional caching via the `noCache` property in the returned value.\n * - **Compatibility**: Designed to work seamlessly with objects and classes in TypeScript or JavaScript.\n */\nexport function cache(_, name, descriptor) {\n    const getter = descriptor.get;\n    if (!getter) {\n        throw error('Getter property descriptor expected');\n    }\n    descriptor.get = function () {\n        if (!IS_PROD) {\n            if (this.isInDestruct) {\n                console.error('Trying to access property in destructed component');\n            }\n        }\n        const value = getter.call(this);\n        if (value && value.noCache === true) {\n            return value;\n        }\n        Object.defineProperty(this, name, {\n            configurable: descriptor.configurable,\n            enumerable: descriptor.enumerable,\n            writable: false,\n            value\n        });\n        return value;\n    };\n}\nexport function cacheHTML(target, _, descriptor) {\n    const fn = descriptor.value;\n    if (!isFunction(fn)) {\n        throw error('Handler must be a Function');\n    }\n    let useCache = true;\n    const cached = new WeakMap();\n    descriptor.value = function (...attrs) {\n        var _a;\n        if (useCache && cached.has(this.constructor)) {\n            return (_a = cached.get(this.constructor)) === null || _a === void 0 ? void 0 : _a.cloneNode(true);\n        }\n        const value = fn.apply(this, attrs);\n        if (useCache && Dom.isElement(value)) {\n            cached.set(this.constructor, value);\n        }\n        return useCache ? value.cloneNode(true) : value;\n    };\n    target.hookStatus(STATUSES.ready, (component) => {\n        const view = isViewObject(component)\n            ? component\n            : component.jodit;\n        useCache = Boolean(view.options.cache);\n    });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,6BAA6B;AACtD,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,GAAG,QAAQ,kBAAkB;AACtC,SAASC,UAAU,EAAEC,YAAY,QAAQ,gCAAgC;AACzE,SAASC,KAAK,QAAQ,oCAAoC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAMA,CAACC,MAAM,EAAEC,QAAQ,EAAE;EACrC,MAAMC,UAAU,GAAGC,MAAM,CAACC,wBAAwB,CAACJ,MAAM,EAAEC,QAAQ,CAAC;EACpE,IAAI,CAACC,UAAU,IAAIN,UAAU,CAACM,UAAU,CAACG,GAAG,CAAC,EAAE;IAC3C,OAAO,IAAI;EACf;EACA,OAAOH,UAAU,CAACI,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,KAAKA,CAACC,CAAC,EAAEC,IAAI,EAAEP,UAAU,EAAE;EACvC,MAAMQ,MAAM,GAAGR,UAAU,CAACG,GAAG;EAC7B,IAAI,CAACK,MAAM,EAAE;IACT,MAAMZ,KAAK,CAAC,qCAAqC,CAAC;EACtD;EACAI,UAAU,CAACG,GAAG,GAAG,YAAY;IACzB,IAAI,CAACX,OAAO,EAAE;MACV,IAAI,IAAI,CAACiB,YAAY,EAAE;QACnBC,OAAO,CAACd,KAAK,CAAC,mDAAmD,CAAC;MACtE;IACJ;IACA,MAAMQ,KAAK,GAAGI,MAAM,CAACG,IAAI,CAAC,IAAI,CAAC;IAC/B,IAAIP,KAAK,IAAIA,KAAK,CAACQ,OAAO,KAAK,IAAI,EAAE;MACjC,OAAOR,KAAK;IAChB;IACAH,MAAM,CAACY,cAAc,CAAC,IAAI,EAAEN,IAAI,EAAE;MAC9BO,YAAY,EAAEd,UAAU,CAACc,YAAY;MACrCC,UAAU,EAAEf,UAAU,CAACe,UAAU;MACjCC,QAAQ,EAAE,KAAK;MACfZ;IACJ,CAAC,CAAC;IACF,OAAOA,KAAK;EAChB,CAAC;AACL;AACA,OAAO,SAASa,SAASA,CAACC,MAAM,EAAEZ,CAAC,EAAEN,UAAU,EAAE;EAC7C,MAAMmB,EAAE,GAAGnB,UAAU,CAACI,KAAK;EAC3B,IAAI,CAACV,UAAU,CAACyB,EAAE,CAAC,EAAE;IACjB,MAAMvB,KAAK,CAAC,4BAA4B,CAAC;EAC7C;EACA,IAAIwB,QAAQ,GAAG,IAAI;EACnB,MAAMvB,MAAM,GAAG,IAAIwB,OAAO,CAAC,CAAC;EAC5BrB,UAAU,CAACI,KAAK,GAAG,UAAU,GAAGkB,KAAK,EAAE;IACnC,IAAIC,EAAE;IACN,IAAIH,QAAQ,IAAIvB,MAAM,CAAC2B,GAAG,CAAC,IAAI,CAACC,WAAW,CAAC,EAAE;MAC1C,OAAO,CAACF,EAAE,GAAG1B,MAAM,CAACM,GAAG,CAAC,IAAI,CAACsB,WAAW,CAAC,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,SAAS,CAAC,IAAI,CAAC;IACtG;IACA,MAAMtB,KAAK,GAAGe,EAAE,CAACQ,KAAK,CAAC,IAAI,EAAEL,KAAK,CAAC;IACnC,IAAIF,QAAQ,IAAI3B,GAAG,CAACmC,SAAS,CAACxB,KAAK,CAAC,EAAE;MAClCP,MAAM,CAACgC,GAAG,CAAC,IAAI,CAACJ,WAAW,EAAErB,KAAK,CAAC;IACvC;IACA,OAAOgB,QAAQ,GAAGhB,KAAK,CAACsB,SAAS,CAAC,IAAI,CAAC,GAAGtB,KAAK;EACnD,CAAC;EACDc,MAAM,CAACY,UAAU,CAACvC,QAAQ,CAACwC,KAAK,EAAGC,SAAS,IAAK;IAC7C,MAAMC,IAAI,GAAGtC,YAAY,CAACqC,SAAS,CAAC,GAC9BA,SAAS,GACTA,SAAS,CAACE,KAAK;IACrBd,QAAQ,GAAGe,OAAO,CAACF,IAAI,CAACG,OAAO,CAAC/B,KAAK,CAAC;EAC1C,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*!\n * Jodit Editor (https://xdsoft.net/jodit/)\n * Released under MIT see LICENSE.txt in the project root for license information.\n * Copyright (c) 2013-2025 Valeriy Chupurnov. All rights reserved. https://xdsoft.net\n */\nimport * as consts from \"../constants.js\";\nimport { globalDocument, INSEPARABLE_TAGS, LIST_TAGS, NO_EMPTY_TAGS, TEMP_ATTR } from \"../constants.js\";\nimport { toArray } from \"../helpers/array/to-array.js\";\nimport { isArray, isFunction, isHTML, isMarker, isSet, isString, isVoid } from \"../helpers/checker/index.js\";\nimport { trim } from \"../helpers/string/trim.js\";\nimport { $$, assert, attr, call, css, dataBind, error } from \"../helpers/utils/index.js\";\n/**\n * Module for working with DOM\n */\nexport class Dom {\n  constructor() {\n    throw new Error('Dom is static module');\n  }\n  /**\n   * Remove all content from element\n   */\n  static detach(node) {\n    while (node && node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n  }\n  /**\n   * Wrap all inline next siblings\n   */\n  static wrapNextInline(current, tag, editor) {\n    let tmp;\n    const first = current;\n    let last = current;\n    editor.s.save();\n    let needFindNext = false;\n    do {\n      needFindNext = false;\n      tmp = last.nextSibling;\n      if (tmp && !Dom.isBlock(tmp) && !Dom.isTag(tmp, 'br')) {\n        needFindNext = true;\n        last = tmp;\n      }\n    } while (needFindNext);\n    return Dom.__wrapElements(tag, editor, first, last);\n  }\n  static __wrapElements(tag, editor, first, last) {\n    const wrapper = isString(tag) ? editor.createInside.element(tag) : tag;\n    if (first.parentNode) {\n      first.parentNode.insertBefore(wrapper, first);\n    }\n    let next = first;\n    while (next) {\n      next = first.nextSibling;\n      wrapper.appendChild(first);\n      if (first === last || !next) {\n        break;\n      }\n      first = next;\n    }\n    editor.s.restore();\n    return wrapper;\n  }\n  /**\n   * Wrap all inline siblings\n   */\n  static wrapInline(current, tag, editor) {\n    let tmp;\n    let first = current;\n    let last = current;\n    editor.s.save();\n    let needFindNext = false;\n    do {\n      needFindNext = false;\n      tmp = first.previousSibling;\n      if (tmp && !Dom.isBlock(tmp)) {\n        needFindNext = true;\n        first = tmp;\n      }\n    } while (needFindNext);\n    do {\n      needFindNext = false;\n      tmp = last.nextSibling;\n      if (tmp && !Dom.isBlock(tmp)) {\n        needFindNext = true;\n        last = tmp;\n      }\n    } while (needFindNext);\n    return Dom.__wrapElements(tag, editor, first, last);\n  }\n  /**\n   * Wrap node inside another node\n   */\n  static wrap(current, tag, create) {\n    const wrapper = isString(tag) ? create.element(tag) : tag;\n    if (Dom.isNode(current)) {\n      if (!current.parentNode) {\n        throw error('Element should be in DOM');\n      }\n      current.parentNode.insertBefore(wrapper, current);\n      wrapper.appendChild(current);\n    } else {\n      const fragment = current.extractContents();\n      current.insertNode(wrapper);\n      wrapper.appendChild(fragment);\n    }\n    return wrapper;\n  }\n  /**\n   * Remove parent of node and insert this node instead that parent\n   */\n  static unwrap(node) {\n    const parent = node.parentNode;\n    if (parent) {\n      while (node.firstChild) {\n        parent.insertBefore(node.firstChild, node);\n      }\n      Dom.safeRemove(node);\n    }\n  }\n  /**\n   * Call functions for all nodes between `start` and `end`\n   */\n  static between(start, end, callback) {\n    let next = start;\n    while (next && next !== end) {\n      if (start !== next && callback(next)) {\n        break;\n      }\n      let step = next.firstChild || next.nextSibling;\n      if (!step) {\n        while (next && !next.nextSibling) {\n          next = next.parentNode;\n        }\n        step = next === null || next === void 0 ? void 0 : next.nextSibling;\n      }\n      next = step;\n    }\n  }\n  static replace(elm, newTagName, create, withAttributes = false, notMoveContent = false) {\n    if (isHTML(newTagName)) {\n      assert(create, 'Need create instance for new tag');\n      newTagName = create.fromHTML(newTagName);\n    }\n    let tag;\n    if (isString(newTagName)) {\n      assert(create, 'Need create instance for new tag');\n      tag = create.element(newTagName);\n    } else {\n      tag = newTagName;\n    }\n    if (!notMoveContent) {\n      while (elm.firstChild) {\n        tag.appendChild(elm.firstChild);\n      }\n    }\n    if (withAttributes && Dom.isElement(elm) && Dom.isElement(tag)) {\n      toArray(elm.attributes).forEach(attr => {\n        tag.setAttribute(attr.name, attr.value);\n      });\n    }\n    if (elm.parentNode) {\n      elm.parentNode.replaceChild(tag, elm);\n    }\n    return tag;\n  }\n  /**\n   * Checks whether the Node text and blank (in this case it may contain invisible auxiliary characters ,\n   * it is also empty )\n   *\n   * @param node - The element of wood to be checked\n   */\n  static isEmptyTextNode(node) {\n    return Dom.isText(node) && (!node.nodeValue || node.nodeValue.replace(consts.INVISIBLE_SPACE_REG_EXP(), '').trim().length === 0);\n  }\n  static isEmptyContent(node) {\n    return Dom.each(node, elm => Dom.isEmptyTextNode(elm));\n  }\n  /**\n   * The node is editable\n   */\n  static isContentEditable(node, root) {\n    return Dom.isNode(node) && !Dom.closest(node, elm => Dom.isElement(elm) && elm.getAttribute('contenteditable') === 'false', root);\n  }\n  static isEmpty(node, condNoEmptyElement = NO_EMPTY_TAGS) {\n    if (!node) {\n      return true;\n    }\n    let cond;\n    if (!isFunction(condNoEmptyElement)) {\n      cond = elm => condNoEmptyElement.has(elm.nodeName.toLowerCase());\n    } else {\n      cond = condNoEmptyElement;\n    }\n    const emptyText = node => node.nodeValue == null || trim(node.nodeValue).length === 0;\n    if (Dom.isText(node)) {\n      return emptyText(node);\n    }\n    return !(Dom.isElement(node) && cond(node)) && Dom.each(node, elm => {\n      if (Dom.isText(elm) && !emptyText(elm) || Dom.isElement(elm) && cond(elm)) {\n        return false;\n      }\n    });\n  }\n  /**\n   * Returns true if it is a DOM node\n   */\n  static isNode(object) {\n    // Duck-typing\n    return Boolean(object && isString(object.nodeName) && typeof object.nodeType === 'number' && object.childNodes && isFunction(object.appendChild));\n  }\n  /**\n   *  Check if element is table cell\n   */\n  static isCell(elm) {\n    return Dom.isNode(elm) && (elm.nodeName === 'TD' || elm.nodeName === 'TH');\n  }\n  /**\n   * Check if element is a list\telement UL or OL\n   */\n  static isList(elm) {\n    return Dom.isTag(elm, LIST_TAGS);\n  }\n  /**\n   * Check if element is a part of list\telement LI\n   */\n  static isLeaf(elm) {\n    return Dom.isTag(elm, 'li');\n  }\n  /**\n   * Check is element is Image element\n   */\n  static isImage(elm) {\n    return Dom.isNode(elm) && /^(img|svg|picture|canvas)$/i.test(elm.nodeName);\n  }\n  /**\n   * Check the `node` is a block element\n   * @param node - Object to check\n   */\n  static isBlock(node) {\n    return !isVoid(node) && typeof node === 'object' && Dom.isNode(node) && consts.IS_BLOCK.test(node.nodeName);\n  }\n  /**\n   * Check if element is text node\n   */\n  static isText(node) {\n    return Boolean(node && node.nodeType === Node.TEXT_NODE);\n  }\n  /**\n   * Check if element is comment node\n   */\n  static isComment(node) {\n    return Boolean(node && node.nodeType === Node.COMMENT_NODE);\n  }\n  /**\n   * Check if element is element node\n   */\n  static isElement(node) {\n    var _a;\n    if (!Dom.isNode(node)) {\n      return false;\n    }\n    const win = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return Boolean(win && node.nodeType === Node.ELEMENT_NODE);\n  }\n  /**\n   * Check if element is document fragment\n   */\n  static isFragment(node) {\n    var _a;\n    if (!Dom.isNode(node)) {\n      return false;\n    }\n    const win = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return Boolean(win && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n  }\n  /**\n   * Check if element is HTMLElement node\n   */\n  static isHTMLElement(node) {\n    var _a;\n    if (!Dom.isNode(node)) {\n      return false;\n    }\n    const win = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return Boolean(win && node instanceof win.HTMLElement);\n  }\n  /**\n   * Check element is inline block\n   */\n  static isInlineBlock(node) {\n    return Dom.isElement(node) && !/^(BR|HR)$/i.test(node.tagName) && ['inline', 'inline-block'].indexOf(css(node, 'display').toString()) !== -1;\n  }\n  /**\n   * It's block and it can be split\n   */\n  static canSplitBlock(node) {\n    return !isVoid(node) && Dom.isHTMLElement(node) && Dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && node.style !== undefined && !/^(fixed|absolute)/i.test(node.style.position);\n  }\n  /**\n   * Get last matched node inside root\n   */\n  static last(root, condition) {\n    let last = root === null || root === void 0 ? void 0 : root.lastChild;\n    if (!last) {\n      return null;\n    }\n    do {\n      if (condition(last)) {\n        return last;\n      }\n      let next = last.lastChild;\n      if (!next) {\n        next = last.previousSibling;\n      }\n      if (!next && last.parentNode !== root) {\n        do {\n          last = last.parentNode;\n        } while (last && !(last === null || last === void 0 ? void 0 : last.previousSibling) && last.parentNode !== root);\n        next = last === null || last === void 0 ? void 0 : last.previousSibling;\n      }\n      last = next;\n    } while (last);\n    return null;\n  }\n  /**\n   * Find previous node\n   */\n  static prev(node, condition, root, withChild = true) {\n    return Dom.find(node, condition, root, false, withChild);\n  }\n  /**\n   * Find next node what `condition(next) === true`\n   */\n  static next(node, condition, root, withChild = true) {\n    return Dom.find(node, condition, root, true, withChild);\n  }\n  static prevWithClass(node, className) {\n    return Dom.prev(node, node => {\n      return Dom.isElement(node) && node.classList.contains(className);\n    }, node.parentNode);\n  }\n  static nextWithClass(node, className) {\n    return Dom.next(node, elm => Dom.isElement(elm) && elm.classList.contains(className), node.parentNode);\n  }\n  /**\n   * Find next/prev node what `condition(next) === true`\n   */\n  static find(node, condition, root, leftToRight = true, withChild = true) {\n    const gen = this.nextGen(node, root, leftToRight, withChild);\n    let item = gen.next();\n    while (!item.done) {\n      if (condition(item.value)) {\n        return item.value;\n      }\n      item = gen.next();\n    }\n    return null;\n  }\n  /**\n   * Find next/prev node what `condition(next) === true`\n   */\n  static *nextGen(start, root, leftToRight = true, withChild = true) {\n    const stack = [];\n    let currentNode = start;\n    do {\n      let next = leftToRight ? currentNode.nextSibling : currentNode.previousSibling;\n      while (next) {\n        stack.unshift(next);\n        next = leftToRight ? next.nextSibling : next.previousSibling;\n      }\n      yield* this.runInStack(start, stack, leftToRight, withChild);\n      currentNode = currentNode.parentNode;\n    } while (currentNode && currentNode !== root);\n    return null;\n  }\n  /**\n   * It goes through all the internal elements of the node, causing a callback function\n   *\n   * @param elm - the element whose children and descendants you want to iterate over\n   * @param callback - It called for each item found\n   * @example\n   * ```javascript\n   * Jodit.modules.Dom.each(editor.s.current(), function (node) {\n   *  if (node.nodeType === Node.TEXT_NODE) {\n   *      node.nodeValue = node.nodeValue.replace(Jodit.INVISIBLE_SPACE_REG_EX, '') // remove all of the text element codes invisible character\n   *  }\n   * });\n   * ```\n   */\n  static each(elm, callback, leftToRight = true) {\n    const gen = this.eachGen(elm, leftToRight);\n    let item = gen.next();\n    while (!item.done) {\n      if (callback(item.value) === false) {\n        return false;\n      }\n      item = gen.next();\n    }\n    return true;\n  }\n  static eachGen(root, leftToRight = true) {\n    return this.runInStack(root, [root], leftToRight);\n  }\n  static *runInStack(start, stack, leftToRight, withChild = true) {\n    while (stack.length) {\n      const item = stack.pop();\n      if (withChild) {\n        let child = leftToRight ? item.lastChild : item.firstChild;\n        while (child) {\n          stack.push(child);\n          child = leftToRight ? child.previousSibling : child.nextSibling;\n        }\n      }\n      if (start !== item) {\n        yield item;\n      }\n    }\n  }\n  /**\n   * Find next/prev node what `condition(next) === true`\n   */\n  static findWithCurrent(node, condition, root, sibling = 'nextSibling', child = 'firstChild') {\n    let next = node;\n    do {\n      if (condition(next)) {\n        return next || null;\n      }\n      if (child && next && next[child]) {\n        const nextOne = Dom.findWithCurrent(next[child], condition, next, sibling, child);\n        if (nextOne) {\n          return nextOne;\n        }\n      }\n      while (next && !next[sibling] && next !== root) {\n        next = next.parentNode;\n      }\n      if (next && next[sibling] && next !== root) {\n        next = next[sibling];\n      }\n    } while (next && next !== root);\n    return null;\n  }\n  /**\n   * Get not empty sibling\n   */\n  static findSibling(node, left = true, cond = n => !Dom.isEmptyTextNode(n)) {\n    let sibling = Dom.sibling(node, left);\n    while (sibling && !cond(sibling)) {\n      sibling = Dom.sibling(sibling, left);\n    }\n    return sibling && cond(sibling) ? sibling : null;\n  }\n  /**\n   * Returns the nearest non-empty sibling\n   */\n  static findNotEmptySibling(node, left) {\n    return Dom.findSibling(node, left, n => {\n      var _a;\n      return !Dom.isEmptyTextNode(n) && Boolean(!Dom.isText(n) || ((_a = n.nodeValue) === null || _a === void 0 ? void 0 : _a.length) && trim(n.nodeValue));\n    });\n  }\n  /**\n   * Returns the nearest non-empty neighbor\n   */\n  static findNotEmptyNeighbor(node, left, root) {\n    return call(left ? Dom.prev : Dom.next, node, n => Boolean(n && (!(Dom.isText(n) || Dom.isComment(n)) || trim((n === null || n === void 0 ? void 0 : n.nodeValue) || '').length)), root);\n  }\n  static sibling(node, left) {\n    return left ? node.previousSibling : node.nextSibling;\n  }\n  /**\n   * It goes through all the elements in ascending order, and checks to see if they meet the predetermined condition\n   */\n  static up(node, condition, root, checkRoot = false) {\n    let start = node;\n    if (!start) {\n      return null;\n    }\n    do {\n      if (condition(start)) {\n        return start;\n      }\n      if (start === root || !start.parentNode) {\n        break;\n      }\n      start = start.parentNode;\n    } while (start && start !== root);\n    if (start === root && checkRoot && condition(start)) {\n      return start;\n    }\n    return null;\n  }\n  static closest(node, tagsOrCondition, root) {\n    let condition;\n    const lc = s => s.toLowerCase();\n    if (isFunction(tagsOrCondition)) {\n      condition = tagsOrCondition;\n    } else if (isArray(tagsOrCondition) || isSet(tagsOrCondition)) {\n      const set = isSet(tagsOrCondition) ? tagsOrCondition : new Set(tagsOrCondition.map(lc));\n      condition = tag => Boolean(tag && set.has(lc(tag.nodeName)));\n    } else {\n      condition = tag => Boolean(tag && lc(tagsOrCondition) === lc(tag.nodeName));\n    }\n    return Dom.up(node, condition, root);\n  }\n  /**\n   * Furthest parent node matching condition\n   */\n  static furthest(node, condition, root) {\n    let matchedParent = null,\n      current = node === null || node === void 0 ? void 0 : node.parentElement;\n    while (current && current !== root) {\n      if (condition(current)) {\n        matchedParent = current;\n      }\n      current = current === null || current === void 0 ? void 0 : current.parentElement;\n    }\n    return matchedParent;\n  }\n  /**\n   * Append new element in the start of root\n   */\n  static appendChildFirst(root, newElement) {\n    const child = root.firstChild;\n    if (child) {\n      if (child !== newElement) {\n        root.insertBefore(newElement, child);\n      }\n    } else {\n      root.appendChild(newElement);\n    }\n  }\n  /**\n   * Insert newElement after element\n   */\n  static after(elm, newElement) {\n    const {\n      parentNode\n    } = elm;\n    if (!parentNode) {\n      return;\n    }\n    if (parentNode.lastChild === elm) {\n      parentNode.appendChild(newElement);\n    } else {\n      parentNode.insertBefore(newElement, elm.nextSibling);\n    }\n  }\n  /**\n   * Insert newElement before element\n   */\n  static before(elm, newElement) {\n    const {\n      parentNode\n    } = elm;\n    if (!parentNode) {\n      return;\n    }\n    parentNode.insertBefore(newElement, elm);\n  }\n  /**\n   * Insert newElement as first child inside element\n   */\n  static prepend(root, newElement) {\n    root.insertBefore(newElement, root.firstChild);\n  }\n  static append(root, newElement) {\n    if (isArray(newElement)) {\n      newElement.forEach(node => {\n        this.append(root, node);\n      });\n    } else {\n      root.appendChild(newElement);\n    }\n  }\n  /**\n   * Move all content to another element\n   */\n  static moveContent(from, to, inStart = false, filter = () => true) {\n    const fragment = (from.ownerDocument || globalDocument).createDocumentFragment();\n    toArray(from.childNodes).filter(elm => {\n      if (filter(elm)) {\n        return true;\n      }\n      Dom.safeRemove(elm);\n      return false;\n    }).forEach(node => {\n      fragment.appendChild(node);\n    });\n    if (!inStart || !to.firstChild) {\n      to.appendChild(fragment);\n    } else {\n      to.insertBefore(fragment, to.firstChild);\n    }\n  }\n  /**\n   * Check root contains child or equal child\n   */\n  static isOrContains(root, child, onlyContains = false) {\n    if (root === child) {\n      return !onlyContains;\n    }\n    return Boolean(child && root && this.up(child, nd => nd === root, root, true));\n  }\n  /**\n   * Safe remove element from DOM\n   */\n  static safeRemove(...nodes) {\n    nodes.forEach(node => Dom.isNode(node) && node.parentNode && node.parentNode.removeChild(node));\n  }\n  static safeInsertNode(range, node) {\n    range.collapsed || range.deleteContents();\n    const child = Dom.isFragment(node) ? node.lastChild : node;\n    if (range.startContainer === range.endContainer && range.collapsed && Dom.isTag(range.startContainer, INSEPARABLE_TAGS)) {\n      Dom.after(range.startContainer, node);\n    } else {\n      range.insertNode(node);\n      child && range.setStartBefore(child);\n    }\n    range.collapse(true);\n    // https://developer.mozilla.org/en-US/docs/Web/API/Range/insertNode\n    // if the new node is to be added to a text Node, that Node is split at the\n    // insertion point, and the insertion occurs between the two text nodes.\n    [node.nextSibling, node.previousSibling].forEach(n => Dom.isText(n) && !n.nodeValue && Dom.safeRemove(n));\n  }\n  /**\n   * Hide element\n   */\n  static hide(node) {\n    if (!node) {\n      return;\n    }\n    dataBind(node, '__old_display', node.style.display);\n    node.style.display = 'none';\n  }\n  /**\n   * Show element\n   */\n  static show(node) {\n    if (!node) {\n      return;\n    }\n    const display = dataBind(node, '__old_display');\n    if (node.style.display === 'none') {\n      node.style.display = display || '';\n    }\n  }\n  static isTag(node, tagNames) {\n    if (!this.isElement(node)) {\n      return false;\n    }\n    const nameL = node.tagName.toLowerCase();\n    const nameU = node.tagName.toUpperCase();\n    if (tagNames instanceof Set) {\n      return tagNames.has(nameL) || tagNames.has(nameU);\n    }\n    if (Array.isArray(tagNames)) {\n      throw new TypeError('Dom.isTag does not support array');\n    }\n    const tags = tagNames;\n    if (nameL === tags || nameU === tags) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Marks an item as temporary\n   */\n  static markTemporary(element, attributes) {\n    attributes && attr(element, attributes);\n    attr(element, TEMP_ATTR, true);\n    return element;\n  }\n  /**\n   * Check if element is temporary\n   */\n  static isTemporary(element) {\n    if (!Dom.isElement(element)) {\n      return false;\n    }\n    return isMarker(element) || attr(element, TEMP_ATTR) === 'true';\n  }\n  /**\n   * Replace temporary elements from string\n   */\n  static replaceTemporaryFromString(value) {\n    return value.replace(/<([a-z]+)[^>]+data-jodit-temp[^>]+>(.+?)<\\/\\1>/gi, '$2');\n  }\n  /**\n   * Get temporary list\n   */\n  static temporaryList(root) {\n    return $$(`[${TEMP_ATTR}]`, root);\n  }\n}","map":{"version":3,"names":["consts","globalDocument","INSEPARABLE_TAGS","LIST_TAGS","NO_EMPTY_TAGS","TEMP_ATTR","toArray","isArray","isFunction","isHTML","isMarker","isSet","isString","isVoid","trim","$$","assert","attr","call","css","dataBind","error","Dom","constructor","Error","detach","node","firstChild","removeChild","wrapNextInline","current","tag","editor","tmp","first","last","s","save","needFindNext","nextSibling","isBlock","isTag","__wrapElements","wrapper","createInside","element","parentNode","insertBefore","next","appendChild","restore","wrapInline","previousSibling","wrap","create","isNode","fragment","extractContents","insertNode","unwrap","parent","safeRemove","between","start","end","callback","step","replace","elm","newTagName","withAttributes","notMoveContent","fromHTML","isElement","attributes","forEach","setAttribute","name","value","replaceChild","isEmptyTextNode","isText","nodeValue","INVISIBLE_SPACE_REG_EXP","length","isEmptyContent","each","isContentEditable","root","closest","getAttribute","isEmpty","condNoEmptyElement","cond","has","nodeName","toLowerCase","emptyText","object","Boolean","nodeType","childNodes","isCell","isList","isLeaf","isImage","test","IS_BLOCK","Node","TEXT_NODE","isComment","COMMENT_NODE","_a","win","ownerDocument","defaultView","ELEMENT_NODE","isFragment","DOCUMENT_FRAGMENT_NODE","isHTMLElement","HTMLElement","isInlineBlock","tagName","indexOf","toString","canSplitBlock","style","undefined","position","condition","lastChild","prev","withChild","find","prevWithClass","className","classList","contains","nextWithClass","leftToRight","gen","nextGen","item","done","stack","currentNode","unshift","runInStack","eachGen","pop","child","push","findWithCurrent","sibling","nextOne","findSibling","left","n","findNotEmptySibling","findNotEmptyNeighbor","up","checkRoot","tagsOrCondition","lc","set","Set","map","furthest","matchedParent","parentElement","appendChildFirst","newElement","after","before","prepend","append","moveContent","from","to","inStart","filter","createDocumentFragment","isOrContains","onlyContains","nd","nodes","safeInsertNode","range","collapsed","deleteContents","startContainer","endContainer","setStartBefore","collapse","hide","display","show","tagNames","nameL","nameU","toUpperCase","Array","TypeError","tags","markTemporary","isTemporary","replaceTemporaryFromString","temporaryList"],"sources":["C:/Users/YDHOOT/Documents/Spring Tool Suite Projects/BlogApplication/frontend_blog_application/node_modules/jodit/esm/core/dom/dom.js"],"sourcesContent":["/*!\n * Jodit Editor (https://xdsoft.net/jodit/)\n * Released under MIT see LICENSE.txt in the project root for license information.\n * Copyright (c) 2013-2025 Valeriy Chupurnov. All rights reserved. https://xdsoft.net\n */\nimport * as consts from \"../constants.js\";\nimport { globalDocument, INSEPARABLE_TAGS, LIST_TAGS, NO_EMPTY_TAGS, TEMP_ATTR } from \"../constants.js\";\nimport { toArray } from \"../helpers/array/to-array.js\";\nimport { isArray, isFunction, isHTML, isMarker, isSet, isString, isVoid } from \"../helpers/checker/index.js\";\nimport { trim } from \"../helpers/string/trim.js\";\nimport { $$, assert, attr, call, css, dataBind, error } from \"../helpers/utils/index.js\";\n/**\n * Module for working with DOM\n */\nexport class Dom {\n    constructor() {\n        throw new Error('Dom is static module');\n    }\n    /**\n     * Remove all content from element\n     */\n    static detach(node) {\n        while (node && node.firstChild) {\n            node.removeChild(node.firstChild);\n        }\n    }\n    /**\n     * Wrap all inline next siblings\n     */\n    static wrapNextInline(current, tag, editor) {\n        let tmp;\n        const first = current;\n        let last = current;\n        editor.s.save();\n        let needFindNext = false;\n        do {\n            needFindNext = false;\n            tmp = last.nextSibling;\n            if (tmp && !Dom.isBlock(tmp) && !Dom.isTag(tmp, 'br')) {\n                needFindNext = true;\n                last = tmp;\n            }\n        } while (needFindNext);\n        return Dom.__wrapElements(tag, editor, first, last);\n    }\n    static __wrapElements(tag, editor, first, last) {\n        const wrapper = isString(tag) ? editor.createInside.element(tag) : tag;\n        if (first.parentNode) {\n            first.parentNode.insertBefore(wrapper, first);\n        }\n        let next = first;\n        while (next) {\n            next = first.nextSibling;\n            wrapper.appendChild(first);\n            if (first === last || !next) {\n                break;\n            }\n            first = next;\n        }\n        editor.s.restore();\n        return wrapper;\n    }\n    /**\n     * Wrap all inline siblings\n     */\n    static wrapInline(current, tag, editor) {\n        let tmp;\n        let first = current;\n        let last = current;\n        editor.s.save();\n        let needFindNext = false;\n        do {\n            needFindNext = false;\n            tmp = first.previousSibling;\n            if (tmp && !Dom.isBlock(tmp)) {\n                needFindNext = true;\n                first = tmp;\n            }\n        } while (needFindNext);\n        do {\n            needFindNext = false;\n            tmp = last.nextSibling;\n            if (tmp && !Dom.isBlock(tmp)) {\n                needFindNext = true;\n                last = tmp;\n            }\n        } while (needFindNext);\n        return Dom.__wrapElements(tag, editor, first, last);\n    }\n    /**\n     * Wrap node inside another node\n     */\n    static wrap(current, tag, create) {\n        const wrapper = isString(tag) ? create.element(tag) : tag;\n        if (Dom.isNode(current)) {\n            if (!current.parentNode) {\n                throw error('Element should be in DOM');\n            }\n            current.parentNode.insertBefore(wrapper, current);\n            wrapper.appendChild(current);\n        }\n        else {\n            const fragment = current.extractContents();\n            current.insertNode(wrapper);\n            wrapper.appendChild(fragment);\n        }\n        return wrapper;\n    }\n    /**\n     * Remove parent of node and insert this node instead that parent\n     */\n    static unwrap(node) {\n        const parent = node.parentNode;\n        if (parent) {\n            while (node.firstChild) {\n                parent.insertBefore(node.firstChild, node);\n            }\n            Dom.safeRemove(node);\n        }\n    }\n    /**\n     * Call functions for all nodes between `start` and `end`\n     */\n    static between(start, end, callback) {\n        let next = start;\n        while (next && next !== end) {\n            if (start !== next && callback(next)) {\n                break;\n            }\n            let step = next.firstChild || next.nextSibling;\n            if (!step) {\n                while (next && !next.nextSibling) {\n                    next = next.parentNode;\n                }\n                step = next === null || next === void 0 ? void 0 : next.nextSibling;\n            }\n            next = step;\n        }\n    }\n    static replace(elm, newTagName, create, withAttributes = false, notMoveContent = false) {\n        if (isHTML(newTagName)) {\n            assert(create, 'Need create instance for new tag');\n            newTagName = create.fromHTML(newTagName);\n        }\n        let tag;\n        if (isString(newTagName)) {\n            assert(create, 'Need create instance for new tag');\n            tag = create.element(newTagName);\n        }\n        else {\n            tag = newTagName;\n        }\n        if (!notMoveContent) {\n            while (elm.firstChild) {\n                tag.appendChild(elm.firstChild);\n            }\n        }\n        if (withAttributes && Dom.isElement(elm) && Dom.isElement(tag)) {\n            toArray(elm.attributes).forEach(attr => {\n                tag.setAttribute(attr.name, attr.value);\n            });\n        }\n        if (elm.parentNode) {\n            elm.parentNode.replaceChild(tag, elm);\n        }\n        return tag;\n    }\n    /**\n     * Checks whether the Node text and blank (in this case it may contain invisible auxiliary characters ,\n     * it is also empty )\n     *\n     * @param node - The element of wood to be checked\n     */\n    static isEmptyTextNode(node) {\n        return (Dom.isText(node) &&\n            (!node.nodeValue ||\n                node.nodeValue\n                    .replace(consts.INVISIBLE_SPACE_REG_EXP(), '')\n                    .trim().length === 0));\n    }\n    static isEmptyContent(node) {\n        return Dom.each(node, (elm) => Dom.isEmptyTextNode(elm));\n    }\n    /**\n     * The node is editable\n     */\n    static isContentEditable(node, root) {\n        return (Dom.isNode(node) &&\n            !Dom.closest(node, elm => Dom.isElement(elm) &&\n                elm.getAttribute('contenteditable') === 'false', root));\n    }\n    static isEmpty(node, condNoEmptyElement = NO_EMPTY_TAGS) {\n        if (!node) {\n            return true;\n        }\n        let cond;\n        if (!isFunction(condNoEmptyElement)) {\n            cond = (elm) => condNoEmptyElement.has(elm.nodeName.toLowerCase());\n        }\n        else {\n            cond = condNoEmptyElement;\n        }\n        const emptyText = (node) => node.nodeValue == null || trim(node.nodeValue).length === 0;\n        if (Dom.isText(node)) {\n            return emptyText(node);\n        }\n        return (!(Dom.isElement(node) && cond(node)) &&\n            Dom.each(node, (elm) => {\n                if ((Dom.isText(elm) && !emptyText(elm)) ||\n                    (Dom.isElement(elm) && cond(elm))) {\n                    return false;\n                }\n            }));\n    }\n    /**\n     * Returns true if it is a DOM node\n     */\n    static isNode(object) {\n        // Duck-typing\n        return Boolean(object &&\n            isString(object.nodeName) &&\n            typeof object.nodeType === 'number' &&\n            object.childNodes &&\n            isFunction(object.appendChild));\n    }\n    /**\n     *  Check if element is table cell\n     */\n    static isCell(elm) {\n        return (Dom.isNode(elm) && (elm.nodeName === 'TD' || elm.nodeName === 'TH'));\n    }\n    /**\n     * Check if element is a list\telement UL or OL\n     */\n    static isList(elm) {\n        return Dom.isTag(elm, LIST_TAGS);\n    }\n    /**\n     * Check if element is a part of list\telement LI\n     */\n    static isLeaf(elm) {\n        return Dom.isTag(elm, 'li');\n    }\n    /**\n     * Check is element is Image element\n     */\n    static isImage(elm) {\n        return (Dom.isNode(elm) && /^(img|svg|picture|canvas)$/i.test(elm.nodeName));\n    }\n    /**\n     * Check the `node` is a block element\n     * @param node - Object to check\n     */\n    static isBlock(node) {\n        return (!isVoid(node) &&\n            typeof node === 'object' &&\n            Dom.isNode(node) &&\n            consts.IS_BLOCK.test(node.nodeName));\n    }\n    /**\n     * Check if element is text node\n     */\n    static isText(node) {\n        return Boolean(node && node.nodeType === Node.TEXT_NODE);\n    }\n    /**\n     * Check if element is comment node\n     */\n    static isComment(node) {\n        return Boolean(node && node.nodeType === Node.COMMENT_NODE);\n    }\n    /**\n     * Check if element is element node\n     */\n    static isElement(node) {\n        var _a;\n        if (!Dom.isNode(node)) {\n            return false;\n        }\n        const win = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n        return Boolean(win && node.nodeType === Node.ELEMENT_NODE);\n    }\n    /**\n     * Check if element is document fragment\n     */\n    static isFragment(node) {\n        var _a;\n        if (!Dom.isNode(node)) {\n            return false;\n        }\n        const win = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n        return Boolean(win && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n    }\n    /**\n     * Check if element is HTMLElement node\n     */\n    static isHTMLElement(node) {\n        var _a;\n        if (!Dom.isNode(node)) {\n            return false;\n        }\n        const win = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n        return Boolean(win && node instanceof win.HTMLElement);\n    }\n    /**\n     * Check element is inline block\n     */\n    static isInlineBlock(node) {\n        return (Dom.isElement(node) &&\n            !/^(BR|HR)$/i.test(node.tagName) &&\n            ['inline', 'inline-block'].indexOf(css(node, 'display').toString()) !== -1);\n    }\n    /**\n     * It's block and it can be split\n     */\n    static canSplitBlock(node) {\n        return (!isVoid(node) &&\n            Dom.isHTMLElement(node) &&\n            Dom.isBlock(node) &&\n            !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &&\n            node.style !== undefined &&\n            !/^(fixed|absolute)/i.test(node.style.position));\n    }\n    /**\n     * Get last matched node inside root\n     */\n    static last(root, condition) {\n        let last = root === null || root === void 0 ? void 0 : root.lastChild;\n        if (!last) {\n            return null;\n        }\n        do {\n            if (condition(last)) {\n                return last;\n            }\n            let next = last.lastChild;\n            if (!next) {\n                next = last.previousSibling;\n            }\n            if (!next && last.parentNode !== root) {\n                do {\n                    last = last.parentNode;\n                } while (last &&\n                    !(last === null || last === void 0 ? void 0 : last.previousSibling) &&\n                    last.parentNode !== root);\n                next = last === null || last === void 0 ? void 0 : last.previousSibling;\n            }\n            last = next;\n        } while (last);\n        return null;\n    }\n    /**\n     * Find previous node\n     */\n    static prev(node, condition, root, withChild = true) {\n        return Dom.find(node, condition, root, false, withChild);\n    }\n    /**\n     * Find next node what `condition(next) === true`\n     */\n    static next(node, condition, root, withChild = true) {\n        return Dom.find(node, condition, root, true, withChild);\n    }\n    static prevWithClass(node, className) {\n        return Dom.prev(node, node => {\n            return (Dom.isElement(node) && node.classList.contains(className));\n        }, node.parentNode);\n    }\n    static nextWithClass(node, className) {\n        return Dom.next(node, elm => Dom.isElement(elm) && elm.classList.contains(className), node.parentNode);\n    }\n    /**\n     * Find next/prev node what `condition(next) === true`\n     */\n    static find(node, condition, root, leftToRight = true, withChild = true) {\n        const gen = this.nextGen(node, root, leftToRight, withChild);\n        let item = gen.next();\n        while (!item.done) {\n            if (condition(item.value)) {\n                return item.value;\n            }\n            item = gen.next();\n        }\n        return null;\n    }\n    /**\n     * Find next/prev node what `condition(next) === true`\n     */\n    static *nextGen(start, root, leftToRight = true, withChild = true) {\n        const stack = [];\n        let currentNode = start;\n        do {\n            let next = leftToRight\n                ? currentNode.nextSibling\n                : currentNode.previousSibling;\n            while (next) {\n                stack.unshift(next);\n                next = leftToRight ? next.nextSibling : next.previousSibling;\n            }\n            yield* this.runInStack(start, stack, leftToRight, withChild);\n            currentNode = currentNode.parentNode;\n        } while (currentNode && currentNode !== root);\n        return null;\n    }\n    /**\n     * It goes through all the internal elements of the node, causing a callback function\n     *\n     * @param elm - the element whose children and descendants you want to iterate over\n     * @param callback - It called for each item found\n     * @example\n     * ```javascript\n     * Jodit.modules.Dom.each(editor.s.current(), function (node) {\n     *  if (node.nodeType === Node.TEXT_NODE) {\n     *      node.nodeValue = node.nodeValue.replace(Jodit.INVISIBLE_SPACE_REG_EX, '') // remove all of the text element codes invisible character\n     *  }\n     * });\n     * ```\n     */\n    static each(elm, callback, leftToRight = true) {\n        const gen = this.eachGen(elm, leftToRight);\n        let item = gen.next();\n        while (!item.done) {\n            if (callback(item.value) === false) {\n                return false;\n            }\n            item = gen.next();\n        }\n        return true;\n    }\n    static eachGen(root, leftToRight = true) {\n        return this.runInStack(root, [root], leftToRight);\n    }\n    static *runInStack(start, stack, leftToRight, withChild = true) {\n        while (stack.length) {\n            const item = stack.pop();\n            if (withChild) {\n                let child = leftToRight ? item.lastChild : item.firstChild;\n                while (child) {\n                    stack.push(child);\n                    child = leftToRight\n                        ? child.previousSibling\n                        : child.nextSibling;\n                }\n            }\n            if (start !== item) {\n                yield item;\n            }\n        }\n    }\n    /**\n     * Find next/prev node what `condition(next) === true`\n     */\n    static findWithCurrent(node, condition, root, sibling = 'nextSibling', child = 'firstChild') {\n        let next = node;\n        do {\n            if (condition(next)) {\n                return next || null;\n            }\n            if (child && next && next[child]) {\n                const nextOne = Dom.findWithCurrent(next[child], condition, next, sibling, child);\n                if (nextOne) {\n                    return nextOne;\n                }\n            }\n            while (next && !next[sibling] && next !== root) {\n                next = next.parentNode;\n            }\n            if (next && next[sibling] && next !== root) {\n                next = next[sibling];\n            }\n        } while (next && next !== root);\n        return null;\n    }\n    /**\n     * Get not empty sibling\n     */\n    static findSibling(node, left = true, cond = (n) => !Dom.isEmptyTextNode(n)) {\n        let sibling = Dom.sibling(node, left);\n        while (sibling && !cond(sibling)) {\n            sibling = Dom.sibling(sibling, left);\n        }\n        return sibling && cond(sibling) ? sibling : null;\n    }\n    /**\n     * Returns the nearest non-empty sibling\n     */\n    static findNotEmptySibling(node, left) {\n        return Dom.findSibling(node, left, n => {\n            var _a;\n            return (!Dom.isEmptyTextNode(n) &&\n                Boolean(!Dom.isText(n) || (((_a = n.nodeValue) === null || _a === void 0 ? void 0 : _a.length) && trim(n.nodeValue))));\n        });\n    }\n    /**\n     * Returns the nearest non-empty neighbor\n     */\n    static findNotEmptyNeighbor(node, left, root) {\n        return call(left ? Dom.prev : Dom.next, node, n => Boolean(n &&\n            (!(Dom.isText(n) || Dom.isComment(n)) ||\n                trim((n === null || n === void 0 ? void 0 : n.nodeValue) || '').length)), root);\n    }\n    static sibling(node, left) {\n        return left ? node.previousSibling : node.nextSibling;\n    }\n    /**\n     * It goes through all the elements in ascending order, and checks to see if they meet the predetermined condition\n     */\n    static up(node, condition, root, checkRoot = false) {\n        let start = node;\n        if (!start) {\n            return null;\n        }\n        do {\n            if (condition(start)) {\n                return start;\n            }\n            if (start === root || !start.parentNode) {\n                break;\n            }\n            start = start.parentNode;\n        } while (start && start !== root);\n        if (start === root && checkRoot && condition(start)) {\n            return start;\n        }\n        return null;\n    }\n    static closest(node, tagsOrCondition, root) {\n        let condition;\n        const lc = (s) => s.toLowerCase();\n        if (isFunction(tagsOrCondition)) {\n            condition = tagsOrCondition;\n        }\n        else if (isArray(tagsOrCondition) || isSet(tagsOrCondition)) {\n            const set = isSet(tagsOrCondition)\n                ? tagsOrCondition\n                : new Set(tagsOrCondition.map(lc));\n            condition = (tag) => Boolean(tag && set.has(lc(tag.nodeName)));\n        }\n        else {\n            condition = (tag) => Boolean(tag && lc(tagsOrCondition) === lc(tag.nodeName));\n        }\n        return Dom.up(node, condition, root);\n    }\n    /**\n     * Furthest parent node matching condition\n     */\n    static furthest(node, condition, root) {\n        let matchedParent = null, current = node === null || node === void 0 ? void 0 : node.parentElement;\n        while (current && current !== root) {\n            if (condition(current)) {\n                matchedParent = current;\n            }\n            current = current === null || current === void 0 ? void 0 : current.parentElement;\n        }\n        return matchedParent;\n    }\n    /**\n     * Append new element in the start of root\n     */\n    static appendChildFirst(root, newElement) {\n        const child = root.firstChild;\n        if (child) {\n            if (child !== newElement) {\n                root.insertBefore(newElement, child);\n            }\n        }\n        else {\n            root.appendChild(newElement);\n        }\n    }\n    /**\n     * Insert newElement after element\n     */\n    static after(elm, newElement) {\n        const { parentNode } = elm;\n        if (!parentNode) {\n            return;\n        }\n        if (parentNode.lastChild === elm) {\n            parentNode.appendChild(newElement);\n        }\n        else {\n            parentNode.insertBefore(newElement, elm.nextSibling);\n        }\n    }\n    /**\n     * Insert newElement before element\n     */\n    static before(elm, newElement) {\n        const { parentNode } = elm;\n        if (!parentNode) {\n            return;\n        }\n        parentNode.insertBefore(newElement, elm);\n    }\n    /**\n     * Insert newElement as first child inside element\n     */\n    static prepend(root, newElement) {\n        root.insertBefore(newElement, root.firstChild);\n    }\n    static append(root, newElement) {\n        if (isArray(newElement)) {\n            newElement.forEach(node => {\n                this.append(root, node);\n            });\n        }\n        else {\n            root.appendChild(newElement);\n        }\n    }\n    /**\n     * Move all content to another element\n     */\n    static moveContent(from, to, inStart = false, filter = () => true) {\n        const fragment = (from.ownerDocument || globalDocument).createDocumentFragment();\n        toArray(from.childNodes)\n            .filter(elm => {\n            if (filter(elm)) {\n                return true;\n            }\n            Dom.safeRemove(elm);\n            return false;\n        })\n            .forEach((node) => {\n            fragment.appendChild(node);\n        });\n        if (!inStart || !to.firstChild) {\n            to.appendChild(fragment);\n        }\n        else {\n            to.insertBefore(fragment, to.firstChild);\n        }\n    }\n    /**\n     * Check root contains child or equal child\n     */\n    static isOrContains(root, child, onlyContains = false) {\n        if (root === child) {\n            return !onlyContains;\n        }\n        return Boolean(child && root && this.up(child, nd => nd === root, root, true));\n    }\n    /**\n     * Safe remove element from DOM\n     */\n    static safeRemove(...nodes) {\n        nodes.forEach(node => Dom.isNode(node) &&\n            node.parentNode &&\n            node.parentNode.removeChild(node));\n    }\n    static safeInsertNode(range, node) {\n        range.collapsed || range.deleteContents();\n        const child = Dom.isFragment(node) ? node.lastChild : node;\n        if (range.startContainer === range.endContainer &&\n            range.collapsed &&\n            Dom.isTag(range.startContainer, INSEPARABLE_TAGS)) {\n            Dom.after(range.startContainer, node);\n        }\n        else {\n            range.insertNode(node);\n            child && range.setStartBefore(child);\n        }\n        range.collapse(true);\n        // https://developer.mozilla.org/en-US/docs/Web/API/Range/insertNode\n        // if the new node is to be added to a text Node, that Node is split at the\n        // insertion point, and the insertion occurs between the two text nodes.\n        [node.nextSibling, node.previousSibling].forEach(n => Dom.isText(n) && !n.nodeValue && Dom.safeRemove(n));\n    }\n    /**\n     * Hide element\n     */\n    static hide(node) {\n        if (!node) {\n            return;\n        }\n        dataBind(node, '__old_display', node.style.display);\n        node.style.display = 'none';\n    }\n    /**\n     * Show element\n     */\n    static show(node) {\n        if (!node) {\n            return;\n        }\n        const display = dataBind(node, '__old_display');\n        if (node.style.display === 'none') {\n            node.style.display = display || '';\n        }\n    }\n    static isTag(node, tagNames) {\n        if (!this.isElement(node)) {\n            return false;\n        }\n        const nameL = node.tagName.toLowerCase();\n        const nameU = node.tagName.toUpperCase();\n        if (tagNames instanceof Set) {\n            return tagNames.has(nameL) || tagNames.has(nameU);\n        }\n        if (Array.isArray(tagNames)) {\n            throw new TypeError('Dom.isTag does not support array');\n        }\n        const tags = tagNames;\n        if (nameL === tags || nameU === tags) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Marks an item as temporary\n     */\n    static markTemporary(element, attributes) {\n        attributes && attr(element, attributes);\n        attr(element, TEMP_ATTR, true);\n        return element;\n    }\n    /**\n     * Check if element is temporary\n     */\n    static isTemporary(element) {\n        if (!Dom.isElement(element)) {\n            return false;\n        }\n        return isMarker(element) || attr(element, TEMP_ATTR) === 'true';\n    }\n    /**\n     * Replace temporary elements from string\n     */\n    static replaceTemporaryFromString(value) {\n        return value.replace(/<([a-z]+)[^>]+data-jodit-temp[^>]+>(.+?)<\\/\\1>/gi, '$2');\n    }\n    /**\n     * Get temporary list\n     */\n    static temporaryList(root) {\n        return $$(`[${TEMP_ATTR}]`, root);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
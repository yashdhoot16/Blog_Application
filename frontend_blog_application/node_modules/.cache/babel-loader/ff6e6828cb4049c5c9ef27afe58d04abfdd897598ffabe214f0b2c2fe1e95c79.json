{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\n\n/**\n * Return a descriptor removing the value and returning a getter\n * The getter will return a .bind version of the function\n * and memoize the result against a symbol on the instance\n */\nexport function boundMethod(target, key, descriptor) {\n  var fn = descriptor.value;\n  if (typeof fn !== 'function') {\n    throw new TypeError(\"@boundMethod decorator can only be applied to methods not: \".concat(_typeof(fn)));\n  } // In IE11 calling Object.defineProperty has a side-effect of evaluating the\n  // getter for the property which is being replaced. This causes infinite\n  // recursion and an \"Out of stack space\" error.\n\n  var definingProperty = false;\n  return {\n    configurable: true,\n    get: function get() {\n      // eslint-disable-next-line no-prototype-builtins\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key) || typeof fn !== 'function') {\n        return fn;\n      }\n      var boundFn = fn.bind(this);\n      definingProperty = true;\n      Object.defineProperty(this, key, {\n        configurable: true,\n        get: function get() {\n          return boundFn;\n        },\n        set: function set(value) {\n          fn = value;\n          delete this[key];\n        }\n      });\n      definingProperty = false;\n      return boundFn;\n    },\n    set: function set(value) {\n      fn = value;\n    }\n  };\n}\n/**\n * Use boundMethod to bind all methods on the target.prototype\n */\n\nexport function boundClass(target) {\n  // (Using reflect to get all keys including symbols)\n  var keys; // Use Reflect if exists\n\n  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\n    keys = Reflect.ownKeys(target.prototype);\n  } else {\n    keys = Object.getOwnPropertyNames(target.prototype); // Use symbols if support is provided\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\n    }\n  }\n  keys.forEach(function (key) {\n    // Ignore special case target method\n    if (key === 'constructor') {\n      return;\n    }\n    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key); // Only methods need binding\n\n    if (typeof descriptor.value === 'function') {\n      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\n    }\n  });\n  return target;\n}\nexport default function autobind() {\n  if (arguments.length === 1) {\n    return boundClass.apply(void 0, arguments);\n  }\n  return boundMethod.apply(void 0, arguments);\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","boundMethod","target","key","descriptor","fn","value","TypeError","concat","definingProperty","configurable","get","hasOwnProperty","boundFn","bind","Object","defineProperty","set","boundClass","keys","Reflect","ownKeys","getOwnPropertyNames","getOwnPropertySymbols","forEach","getOwnPropertyDescriptor","autobind","arguments","length","apply"],"sources":["C:/Users/YDHOOT/Documents/Spring Tool Suite Projects/BlogApplication/frontend_blog_application/node_modules/autobind-decorator/lib/esm/index.js"],"sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return a descriptor removing the value and returning a getter\n * The getter will return a .bind version of the function\n * and memoize the result against a symbol on the instance\n */\nexport function boundMethod(target, key, descriptor) {\n  var fn = descriptor.value;\n\n  if (typeof fn !== 'function') {\n    throw new TypeError(\"@boundMethod decorator can only be applied to methods not: \".concat(_typeof(fn)));\n  } // In IE11 calling Object.defineProperty has a side-effect of evaluating the\n  // getter for the property which is being replaced. This causes infinite\n  // recursion and an \"Out of stack space\" error.\n\n\n  var definingProperty = false;\n  return {\n    configurable: true,\n    get: function get() {\n      // eslint-disable-next-line no-prototype-builtins\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key) || typeof fn !== 'function') {\n        return fn;\n      }\n\n      var boundFn = fn.bind(this);\n      definingProperty = true;\n      Object.defineProperty(this, key, {\n        configurable: true,\n        get: function get() {\n          return boundFn;\n        },\n        set: function set(value) {\n          fn = value;\n          delete this[key];\n        }\n      });\n      definingProperty = false;\n      return boundFn;\n    },\n    set: function set(value) {\n      fn = value;\n    }\n  };\n}\n/**\n * Use boundMethod to bind all methods on the target.prototype\n */\n\nexport function boundClass(target) {\n  // (Using reflect to get all keys including symbols)\n  var keys; // Use Reflect if exists\n\n  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\n    keys = Reflect.ownKeys(target.prototype);\n  } else {\n    keys = Object.getOwnPropertyNames(target.prototype); // Use symbols if support is provided\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\n    }\n  }\n\n  keys.forEach(function (key) {\n    // Ignore special case target method\n    if (key === 'constructor') {\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key); // Only methods need binding\n\n    if (typeof descriptor.value === 'function') {\n      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\n    }\n  });\n  return target;\n}\nexport default function autobind() {\n  if (arguments.length === 1) {\n    return boundClass.apply(void 0, arguments);\n  }\n\n  return boundMethod.apply(void 0, arguments);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}